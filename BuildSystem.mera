capsule BuildGraph {
    var nodes: dict<string, list<string>> = {}  // filename -> dependencies

    func add_node(file: string, deps: list<string>) {
        nodes[file] = deps
    }

    func build_order() -> list<string> {
        var visited = set<string>()
        var result = list<string>()

        func visit(n: string) {
            if visited.contains(n) { return }
            visited.add(n)
            for dep in nodes.get(n, []) {
                visit(dep)
            }
            result.append(n)
        }

        for node in nodes.keys() {
            visit(node)
        }
        return result
    }
}

capsule BuildSystem {
    import FileIO
    import Hashing
    import Lexer
    import Parser
    import MacroProcessor
    import Assembler
    import Linker

    var dep_graph: dict<string,list<string>> = {}
    var build_cache: dict<string,string> = {}

    func parse_dependencies(file: string) -> list<string> {
        val deps = list<string>()
        val src = file_read_text(file)
        for line in src.split("\n") {
            val trimmed = line.trim()
            if trimmed.starts_with("#include") {
                val inc = extract_include_filename(trimmed)
                deps.append(inc)
            } else if trimmed.starts_with("import") {
                val imp = extract_import_filename(trimmed)
                deps.append(imp)
            }
        }
        return deps
    }

    func build_project(entry_files: list<string>) {
        // Build dependency graph
        for file in entry_files {
            dep_graph[file] = parse_dependencies(file)
        }

        val graph = BuildGraph()
        for (file, deps) in dep_graph {
            graph.add_node(file, deps)
        }

        val order = graph.build_order()

        for file in order {
            val source_hash = Hashing.file_sha256(file)
            val cache_key = file + ":" + source_hash
            if build_cache.contains_key(cache_key) {
                say("Skipping " + file + ", using cached build.")
                continue
            }

            say("Building " + file)
            val src = file_read_text(file)

            Lexer.tokenize(src)
            Parser.parse()
            MacroProcessor.expand_macros()
            Assembler.first_pass()
            Assembler.second_pass()

            Linker.add_section(".text", Assembler.code_bytes)
            Linker.link()

            Assembler.write_exe(file + ".exe")

            build_cache[cache_key] = file + ".exe"
        }
    }
}

capsule CLI {
    import Lexer
    import Parser
    import MacroProcessor
    import OpcodeDatabase
    import Assembler
    import Linker
    import BuildGraph
    import BuildSystem
    import ConcurrentBuildSystem

    func parse_sources(args: list<string>) -> list<string> {
        return args
    }

    func find_dependencies(file: string) -> list<string> {
        return BuildSystem.parse_dependencies(file)
    }

    func run(args: list<string>) {
        if args.length == 0 {
            say("Usage: meraasm <input.asm> [-o output.exe] [--debug] [--verbose]")
            return
        }

        // Detect if single-file build or multi-file build
        if args.length == 1 || (!args.contains("-o") && !args.contains("--debug") && !args.contains("--verbose")) {
            // Single file simple build
            val infile = args[0]
            val outfile = if args.contains("-o") then args[args.index_of("-o") + 1] else "a.exe"
            val debug = args.contains("--debug")
            val verbose = args.contains("--verbose")

            val source = file_read_text(infile)

            if verbose { say("Tokenizing...") }
            Lexer.tokenize(source)
            if verbose { say("Parsing...") }
            Parser.parse()
            if verbose { say("Expanding macros...") }
            MacroProcessor.expand_macros()
            if verbose { say("Initializing opcode database...") }
            OpcodeDatabase.initialize()

            if verbose { say("Assembling...") }
            Assembler.first_pass()
            Assembler.second_pass()

            if verbose { say("Linking...") }
            Linker.add_section(".text", Assembler.code_bytes)
            Linker.link()

            if debug { say("Embedding debug info...") }
            // TODO: Embed debug info here

            if verbose { say("Writing executable...") }
            Assembler.write_exe(outfile)

            say("Assembled " + infile + " -> " + outfile)
        } else {
            // Multi-file build with dependency graph & concurrency
            val sources = parse_sources(args)
            val graph = BuildGraph()
            for src in sources {
                graph.add_node(src, find_dependencies(src))
            }
            val order = graph.build_order()

            val parse_tasks = list<ConcurrentBuildSystem.TaskHandle>()
            for file in order {
                parse_tasks.append(ConcurrentBuildSystem.launch_lex_parse(file))
            }
            val parsed_results = ConcurrentBuildSystem.wait_all_tasks()

            // TODO: Parallel macro expansion, assembly, linking...

            say("Build completed.")
        }
    }
}
