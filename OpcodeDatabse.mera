capsule OpcodeDatabase {
    import Dodecagram
    import SymbolTable
    import RelocationTable

    // Opcode entry structure with operand pattern matching and encoding logic
    struct OpcodeEntry {
        mnemonic: string
        operand_patterns: list<string>  // E.g. ["REG32","IMM32"], ["REG32","REG32"], ["LABEL"]
        encode_func: func(list<Parser.Operand>, int) -> bytes
    }

    var opcode_table: list<OpcodeEntry> = []

    // Initialization: use data-driven approach to generate entries
    func initialize() {
        opcode_table.clear()
        generate_mov_instructions()
        generate_xor_instructions()
        generate_call_ret()
        generate_add_sub_inc_dec()
        // Extend with hundreds/thousands more via similar pattern generators
    }

    // Generate MOV reg, imm32 opcodes for all registers
    func generate_mov_instructions() {
        val regs = ["eax","ecx","edx","ebx","esp","ebp","esi","edi"]
        for r in regs {
            opcode_table.append(OpcodeEntry{
                mnemonic: "mov",
                operand_patterns: ["REG32","IMM32"],
                encode_func: func(ops: list<Parser.Operand>, addr: int) -> bytes {
                    if ops[0].text != r { return [] } // Only for this reg
                    val imm = parse_imm(ops[1].text)
                    val base_opcode = 0xB8 + reg_code(r)
                    return [base_opcode] + imm32_to_bytes(imm)
                }
            })
        }
    }

    // Generate XOR reg, reg instructions for all reg pairs
    func generate_xor_instructions() {
        val regs = ["eax","ecx","edx","ebx","esp","ebp","esi","edi"]
        for r1 in regs {
            for r2 in regs {
                opcode_table.append(OpcodeEntry{
                    mnemonic: "xor",
                    operand_patterns: ["REG32","REG32"],
                    encode_func: func(ops: list<Parser.Operand>, addr: int) -> bytes {
                        if ops[0].text != r1 || ops[1].text != r2 { return [] }
                        val modrm = 0xC0 + reg_code(r2) * 8 + reg_code(r1)
                        return [0x31, modrm]
                    }
                })
            }
        }
    }

    // Generate CALL label and RET
    func generate_call_ret() {
        opcode_table.append(OpcodeEntry{
            mnemonic: "call",
            operand_patterns: ["LABEL"],
            encode_func: func(ops: list<Parser.Operand>, addr: int) -> bytes {
                RelocationTable.add(addr + 1, ops[0].text)
                return [0xE8, 0, 0, 0, 0]
            }
        })
        opcode_table.append(OpcodeEntry{
            mnemonic: "ret",
            operand_patterns: [],
            encode_func: func(_ops: list<Parser.Operand>, _addr: int) -> bytes {
                return [0xC3]
            }
        })
    }

    // Generate ADD, SUB, INC, DEC instructions
    func generate_add_sub_inc_dec() {
        val regs = ["eax","ecx","edx","ebx","esp","ebp","esi","edi"]

        // ADD reg, reg
        for r1 in regs {
            for r2 in regs {
                opcode_table.append(OpcodeEntry{
                    mnemonic: "add",
                    operand_patterns: ["REG32","REG32"],
                    encode_func: func(ops: list<Parser.Operand>, _addr: int) -> bytes {
                        if ops[0].text != r1 || ops[1].text != r2 { return [] }
                        val modrm = 0xC0 + reg_code(r2) * 8 + reg_code(r1)
                        return [0x01, modrm]
                    }
                })
            }
        }

        // SUB reg, imm8
        for r in regs {
            opcode_table.append(OpcodeEntry{
                mnemonic: "sub",
                operand_patterns: ["REG32","IMM8"],
                encode_func: func(ops: list<Parser.Operand>, _addr: int) -> bytes {
                    if ops[0].text != r { return [] }
                    val imm = parse_imm(ops[1].text)
                    return [0x83, 0xE8 + reg_code(r), imm & 0xFF]
                }
            })
        }

        // INC reg
        for r in regs {
            opcode_table.append(OpcodeEntry{
                mnemonic: "inc",
                operand_patterns: ["REG32"],
                encode_func: func(ops: list<Parser.Operand>, _addr: int) -> bytes {
                    if ops[0].text != r { return [] }
                    return [0x40 + reg_code(r)]
                }
            })
        }

        // DEC reg
        for r in regs {
            opcode_table.append(OpcodeEntry{
                mnemonic: "dec",
                operand_patterns: ["REG32"],
                encode_func: func(ops: list<Parser.Operand>, _addr: int) -> bytes {
                    if ops[0].text != r { return [] }
                    return [0x48 + reg_code(r)]
                }
            })
        }
    }

    // Helper utilities
    func reg_code(reg: string) -> int {
        switch reg {
            case "eax": return 0
            case "ecx": return 1
            case "edx": return 2
            case "ebx": return 3
            case "esp": return 4
            case "ebp": return 5
            case "esi": return 6
            case "edi": return 7
            default: error("Unknown register " + reg)
        }
    }

    func parse_imm(text: string) -> int {
        if text.starts_with("0x") {
            return parse_hex(text)
        }
        return int(text)
    }

    func parse_hex(text: string) -> int {
        val hexstr = if text.starts_with("0x") then text.substr(2) else text
        var result = 0
        for ch in hexstr.to_lower() {
            val digit = if ch >= '0' && ch <= '9' then (int)ch - (int)'0'
                        else if ch >= 'a' && ch <= 'f' then 10 + ((int)ch - (int)'a')
                        else error("Invalid hex digit: " + ch)
            result = result * 16 + digit
        }
        return result
    }

    func imm32_to_bytes(val: int) -> bytes {
        return [
            val & 0xFF,
            (val >> 8) & 0xFF,
            (val >> 16) & 0xFF,
            (val >> 24) & 0xFF
        ]
    }

    // Encodes a Parser.Instruction using the opcode table
    func encode(instr: Parser.Instruction, addr: int) -> bytes {
        for entry in opcode_table {
            if entry.mnemonic == instr.mnemonic &&
               entry.operand_patterns.length == instr.operands.length {
                var match = true
                for i in 0 .. instr.operands.length - 1 {
                    if !operand_matches(instr.operands[i], entry.operand_patterns[i]) {
                        match = false
                        break
                    }
                }
                if match {
                    val encoded = entry.encode_func(instr.operands, addr)
                    if encoded.length > 0 {
                        return encoded
                    }
                }
            }
        }
        error("Unsupported instruction at line " + instr.line + ": " + instr.mnemonic)
    }

    func operand_matches(op: Parser.Operand, pattern: string) -> bool {
        switch pattern {
            case "REG32": return op.type == "REGISTER"
            case "IMM32": return op.type == "IMMEDIATE"
            case "IMM8": return op.type == "IMMEDIATE"
            case "LABEL": return op.type == "LABEL"
            default: return false
        }
    }
}
