capsule Debugger {
    // --- Debugger Core State ---
    var source_map: dict<int, string> = {}
    var breakpoints: set<int> = {}
    var watchpoints: dict<string, int> = {}
    var current_pc: int = 0
    var registers: dict<string, int64> = {}

    // Record source line for address (disassembly / debug info)
    func record_source(address: int, line: string) {
        source_map[address] = line
    }

    // Breakpoint management
    func set_breakpoint(addr: int) {
        breakpoints.add(addr)
    }
    func remove_breakpoint(addr: int) {
        breakpoints.remove(addr)
    }
    func check_breakpoint(addr: int) -> bool {
        return breakpoints.contains(addr)
    }

    func get_source_line(addr: int) -> string? {
        return source_map.get(addr, null)
    }

    // Called on instruction execution
    func on_instruction(addr: int) {
        current_pc = addr
        if check_breakpoint(addr) {
            pause_execution()
        }
    }

    // Register accessors
    func read_register(name: string) -> int64 {
        return registers.get(name, 0)
    }
    func write_register(name: string, val: int64) {
        registers[name] = val
    }

    // Pause execution placeholder (to be connected to UI or CLI)
    func pause_execution() {
        say("Execution paused at 0x" + current_pc.to_string(16))
        // Await user input: step, continue, inspect, etc.
    }

    // Step execution (stub)
    func step() {
        say("Stepping at 0x" + current_pc.to_string(16))
        // Implement stepping logic here
    }

    // Continue execution (stub)
    func continue_execution() {
        say("Continuing execution from 0x" + current_pc.to_string(16))
        // Implement continue logic here
    }
}

capsule DebuggerGUI {
    import Debugger

    var is_running: bool = false
    var current_pc: int = 0
    var registers: dict<string,int64> = {}

    // Render the debugger window
    func render() {
        draw_window("Debugger")

        draw_text("PC: 0x" + current_pc.to_string(16))
        draw_separator()

        for reg in ["rax","rbx","rcx","rdx","rsi","rdi","rsp","rbp","rip"] {
            draw_text(reg + ": 0x" + registers.get(reg,0).to_string(16))
        }

        draw_separator()
        draw_text("Breakpoints:")
        for bp in Debugger.breakpoints {
            draw_text("  0x" + bp.to_string(16))
        }

        if button("Step") {
            Debugger.step()
        }
        if button("Continue") {
            Debugger.continue_execution()
        }
        if button("Pause") {
            Debugger.pause_execution()
        }
    }

    // Update GUI state from Debugger runtime
    func update_state(pc: int, regs: dict<string,int64>) {
        current_pc = pc
        registers = regs
    }
}
