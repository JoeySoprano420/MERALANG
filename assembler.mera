capsule Assembler {
    import Parser
    import SymbolTable
    import RelocationTable
    import OpcodeTable
    import PEHeader
    import Dodecagram
    import FileIO

    var code_bytes: bytes = []

    // First pass: calculate addresses and generate code with placeholder for calls
    func first_pass() {
        var addr = 0
        for instr in Parser.instructions {
            if Parser.labels.contains_key(instr.mnemonic) {
                SymbolTable.define_label(instr.mnemonic, addr)
            }
            val bytes = OpcodeTable.encode(instr, addr)
            code_bytes.extend(bytes)
            addr += bytes.length
        }
    }

    // Second pass: fix relocations for call instructions
    func second_pass() {
        for reloc in RelocationTable.relocations {
            val target = SymbolTable.resolve_label(reloc.label)
            val rel = target - (reloc.position + 4)
            code_bytes[reloc.position] = rel & 0xFF
            code_bytes[reloc.position + 1] = (rel >> 8) & 0xFF
            code_bytes[reloc.position + 2] = (rel >> 16) & 0xFF
            code_bytes[reloc.position + 3] = (rel >> 24) & 0xFF
        }
    }

    // Build full PE file including import tables and code section
    func build_pe_file() -> bytes {
        // Compose all headers and sections together
        val dos_stub = PEHeader.dos_stub
        val pe_sig = PEHeader.pe_sig
        val coff_header = PEHeader.coff_header
        val optional_header = PEHeader.optional_header
        val section_header = PEHeader.section_header(code_bytes.length)

        val import_dir = PEHeader.build_import_directory()
        val thunk_tbl = PEHeader.build_thunk_table()
        val imp_names = PEHeader.build_import_names()
        val fn_name = PEHeader.build_function_name()

        // Layout file parts (simplified)
        var file = []
        file.extend(dos_stub)
        while file.length < 0x80 {
            file.append(0)
        }
        file.extend(pe_sig)
        file.extend(coff_header)
        file.extend(optional_header)
        file.extend(section_header)

        // Pad to 0x400 for section start
        while file.length < 0x400 {
            file.append(0)
        }
        file.extend(code_bytes)

        // Import directory at 0x2000 (needs proper addressing in optional header!)
        while file.length < 0x2000 {
            file.append(0)
        }
        file.extend(import_dir)

        while file.length < 0x2100 {
            file.append(0)
        }
        file.extend(thunk_tbl)

        while file.length < 0x2200 {
            file.append(0)
        }
        file.extend(imp_names)

        while file.length < 0x2300 {
            file.append(0)
        }
        file.extend(fn_name)

        return file
    }

    func write_exe(filename: string) {
        val pe = build_pe_file()
        FileIO.write_binary(filename, pe)
    }
}
