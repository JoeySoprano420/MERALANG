capsule Assembler {
    import Parser
    import SymbolTable
    import OpcodeTable
    import Dodecagram
    import PEHeader
    import FileIO

    var code_bytes: bytes = []
    var fixups: list<{position: int, label: string}> = []

    // First pass: assign addresses to labels, build code with placeholders
    func first_pass() {
        var address = 0
        for instr in Parser.instructions {
            if instr.mnemonic == "label" {
                SymbolTable.define_label(instr.operands[0], address)
            } else {
                val opcode_bytes = OpcodeTable.encode(instr)
                if instr.mnemonic == "call" {
                    // record fixup for label call
                    fixups.append({position: address + 1, label: instr.operands[0]})
                }
                address += opcode_bytes.length
                code_bytes.extend(opcode_bytes)
            }
        }
    }

    // Second pass: patch calls with correct relative offsets
    func second_pass() {
        for fixup in fixups {
            val target_address = SymbolTable.resolve_label(fixup.label)
            val call_site = fixup.position
            val rel_offset = target_address - (call_site + 4) // 4 = size of rel32 operand
            // Patch code_bytes at call_site with rel_offset little endian
            code_bytes[call_site] = rel_offset & 0xFF
            code_bytes[call_site + 1] = (rel_offset >> 8) & 0xFF
            code_bytes[call_site + 2] = (rel_offset >> 16) & 0xFF
            code_bytes[call_site + 3] = (rel_offset >> 24) & 0xFF
        }
    }

    // Build final PE file bytes including imports for ExitProcess
    func build_pe_file() -> bytes {
        // For brevity, imports & thunk table generation omitted here, assume fixed for ExitProcess

        val code_len = code_bytes.length
        val padded_len = ((code_len + 0x1FF) & ~0x1FF)
        val padding = padded_len - code_len
        for _ in 0 .. padding - 1 {
            code_bytes.append(0)
        }

        val file_bytes = []
        file_bytes.extend(PEHeader.dos_stub)
        val pe_header_offset = 0x80
        val current_len = file_bytes.length
        for _ in 0 .. pe_header_offset - current_len - 1 {
            file_bytes.append(0)
        }

        file_bytes.extend(PEHeader.pe_sig)
        file_bytes.extend(PEHeader.coff_header)
        file_bytes.extend(PEHeader.optional_header)
        file_bytes.extend(PEHeader.section_header(padded_len))

        val headers_len = file_bytes.length
        for _ in 0 .. 0x400 - headers_len - 1 {
            file_bytes.append(0)
        }

        file_bytes.extend(code_bytes)
        return file_bytes
    }

    func write_exe(filename: string) {
        val pe_bytes = build_pe_file()
        FileIO.write_binary(filename, pe_bytes)
    }
}
