capsule Linker {
    import Assembler
    import PEBuilder
    import SymbolTable
    import RelocationTable

    var sections: dict<string, bytes> = {}

    func add_section(name: string, data: bytes) {
        sections[name] = data
    }

    func link() {
        // Resolve all symbols and relocations
        var final_code = bytes()
        for name in sections.keys() {
            final_code.extend(sections[name])
        }
        Assembler.code_bytes = final_code

        // Patch relocations with label addresses
        for reloc in RelocationTable.relocations {
            val target_addr = SymbolTable.resolve_label(reloc.label)
            val rel_offset = target_addr - (reloc.position + 4)
            Assembler.code_bytes[reloc.position] = rel_offset & 0xFF
            Assembler.code_bytes[reloc.position + 1] = (rel_offset >> 8) & 0xFF
            Assembler.code_bytes[reloc.position + 2] = (rel_offset >> 16) & 0xFF
            Assembler.code_bytes[reloc.position + 3] = (rel_offset >> 24) & 0xFF
        }
    }

    // Import Table construction with ExitProcess thunk stub
    func build_import_table() -> bytes {
        // Build IMAGE_IMPORT_DESCRIPTOR + thunk tables + strings
        // See PE spec for layout, typically at section end
        // This is a detailed binary structureâ€”prepare the bytes accordingly
        // For brevity, assume static offsets and build a correct import for kernel32.dll ExitProcess

        val import_dir = PEBuilder.build_import_directory()
        val thunk_table = PEBuilder.build_thunk_table()
        val import_names = PEBuilder.build_import_names()
        val function_name = PEBuilder.build_function_name()

        var import_table = bytes()
        import_table.extend(import_dir)
        import_table.extend(thunk_table)
        import_table.extend(import_names)
        import_table.extend(function_name)

        return import_table
    }
}
