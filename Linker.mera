capsule Linker {
    import PEBuilder
    import RelocationTable
    import SymbolTable
    import Assembler

    var sections: dict<string, bytes> = {}

    func add_section(name: string, data: bytes) {
        sections[name] = data
    }

    func link() {
        // Concatenate all sections in insertion order
        var full_code = bytes()
        for section_name in sections.keys() {
            full_code.extend(sections[section_name])
        }
        Assembler.code_bytes = full_code

        // Patch relocations: calculate relative offsets for labels
        for reloc in RelocationTable.relocations {
            val target_addr = SymbolTable.resolve_label(reloc.label)
            val rel_offset = target_addr - (reloc.position + 4) // 4 = size of relative offset
            Assembler.code_bytes[reloc.position]     = rel_offset & 0xFF
            Assembler.code_bytes[reloc.position + 1] = (rel_offset >> 8) & 0xFF
            Assembler.code_bytes[reloc.position + 2] = (rel_offset >> 16) & 0xFF
            Assembler.code_bytes[reloc.position + 3] = (rel_offset >> 24) & 0xFF
        }
    }

    func build_import_table() -> bytes {
        // Build full import table for kernel32.dll's ExitProcess function
        // This combines:
        // - Import Directory Table
        // - Import Lookup Table / IAT (thunk table)
        // - DLL and function name strings
        // Stub implementations delegate to PEBuilder

        val import_directory = PEBuilder.build_import_directory()
        val thunk_table      = PEBuilder.build_thunk_table()
        val import_names     = PEBuilder.build_import_names()
        val function_name    = PEBuilder.build_function_name()

        var import_table = bytes()
        import_table.extend(import_directory)
        import_table.extend(thunk_table)
        import_table.extend(import_names)
        import_table.extend(function_name)

        return import_table
    }
}
