capsule Dodecagram {
    // Map a single dodecagram char to base-12 digit (0..11)
    func char_to_digit(ch: char) -> int {
        if ch >= '0' && ch <= '9' {
            return (int)ch - (int)'0'
        } else if ch == 'a' {
            return 10
        } else if ch == 'b' {
            return 11
        } else {
            error("Invalid dodecagram char: " + ch)
        }
    }

    // Parse base-12 string into integer
    func parse_base12(str: string) -> int {
        val len = str.length
        val result = 0
        var i = 0
        loop i < len {
            val digit = char_to_digit(str[i])
            result = result * 12 + digit
            i += 1
        }
        return result
    }
}

capsule PEHeader {
    // Minimal DOS header + stub (64 bytes)
    val dos_stub: bytes = [
        0x4D,0x5A,0x90,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,
        0xB8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
        0x0E,0x1F,0xBA,0x0E,0x00,0xB4,0x09,0xCD,0x21,0xB8,0x01,0x4C,0xCD,0x21,0x54,0x68
    ]

    // PE Signature "PE\0\0"
    val pe_sig: bytes = [0x50, 0x45, 0x00, 0x00]

    // COFF File header (Machine=0x14c Intel 386, 1 section, no timestamps, size of optional header=224)
    val coff_header: bytes = [
        0x4C, 0x01,             // Machine = Intel 386
        0x01, 0x00,             // Number of sections = 1
        0x00, 0x00, 0x00, 0x00, // TimeDateStamp = 0
        0x00, 0x00, 0x00, 0x00, // PointerToSymbolTable = 0
        0x00, 0x00, 0x00, 0x00, // NumberOfSymbols = 0
        0xE0, 0x00              // SizeOfOptionalHeader = 224 bytes
    ]

    // Optional header (Standard fields + windows fields, minimal)
    val optional_header: bytes = [
        0x0B, 0x01,             // Magic PE32
        0x08,                   // MajorLinkerVersion
        0x00,                   // MinorLinkerVersion
        0x00, 0x02, 0x00, 0x00, // SizeOfCode (512 bytes, 0x200)
        0x00, 0x00, 0x00, 0x00, // SizeOfInitializedData
        0x00, 0x00, 0x00, 0x00, // SizeOfUninitializedData
        0x00, 0x10, 0x00, 0x00, // AddressOfEntryPoint (0x1000) — start of .text
        0x00, 0x10, 0x00, 0x00, // BaseOfCode (0x1000)
        0x00, 0x00, 0x40, 0x00, // ImageBase (0x400000)
        0x00, 0x10, 0x00, 0x00, // SectionAlignment (0x1000)
        0x00, 0x02, 0x00, 0x00, // FileAlignment (0x200)
        0x04, 0x00,             // MajorOperatingSystemVersion
        0x00, 0x00,             // MinorOperatingSystemVersion
        0x00, 0x00,             // MajorImageVersion
        0x00, 0x00,             // MinorImageVersion
        0x04, 0x00,             // MajorSubsystemVersion
        0x00, 0x00,             // MinorSubsystemVersion
        0x00, 0x00, 0x00, 0x00, // Win32VersionValue
        0x00, 0x02, 0x00, 0x00, // SizeOfImage (0x2000) — 2 sections * 4096
        0x00, 0x04, 0x00, 0x00, // SizeOfHeaders (0x400)
        0x00, 0x00, 0x00, 0x00, // CheckSum
        0x03, 0x00,             // Subsystem (Windows CUI)
        0x00, 0x00,             // DllCharacteristics
        0x00, 0x10, 0x00, 0x00, // SizeOfStackReserve
        0x00, 0x10, 0x00, 0x00, // SizeOfStackCommit
        0x00, 0x10, 0x00, 0x00, // SizeOfHeapReserve
        0x00, 0x10, 0x00, 0x00, // SizeOfHeapCommit
        0x00, 0x00, 0x00, 0x00, // LoaderFlags
        0x10, 0x00, 0x00, 0x00, // NumberOfRvaAndSizes = 16
        // Data directories (all zero)
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Export Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Import Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Resource Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Exception Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Certificate Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Base Relocation Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Debug
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Architecture
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Global Ptr
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // TLS Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Load Config Table
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bound Import
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // IAT
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Delay Import Descriptor
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CLR Runtime Header
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // Reserved
    ]

    // Section header for .text
    func section_header(code_size: int) -> bytes {
        val header = [
            0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, // Name = ".text\0\0\0"
            0x00, 0x02, 0x00, 0x00,                         // VirtualSize (0x200 bytes)
            0x00, 0x10, 0x00, 0x00,                         // VirtualAddress (0x1000)
            0x00, 0x02, 0x00, 0x00,                         // SizeOfRawData (0x200 bytes)
            0x00, 0x04, 0x00, 0x00,                         // PointerToRawData (0x400)
            0x00, 0x00, 0x00, 0x00,                         // PointerToRelocations
            0x00, 0x00, 0x00, 0x00,                         // PointerToLinenumbers
            0x00, 0x00,                                     // NumberOfRelocations
            0x00, 0x00,                                     // NumberOfLinenumbers
            0x20, 0x00, 0x00, 0x60                          // Characteristics = executable + readable + code
        ]

        // patch VirtualSize and SizeOfRawData with actual code_size (little endian)
        header[8] = (code_size & 0xFF)
        header[9] = ((code_size >> 8) & 0xFF)
        header[10] = ((code_size >> 16) & 0xFF)
        header[11] = ((code_size >> 24) & 0xFF)

        header[16] = (code_size & 0xFF)
        header[17] = ((code_size >> 8) & 0xFF)
        header[18] = ((code_size >> 16) & 0xFF)
        header[19] = ((code_size >> 24) & 0xFF)

        return header
    }
}

capsule Assembler {
    import Dodecagram
    import PEHeader

    var code_bytes: bytes = []

    // Convert base-12 dodecagram string into raw bytes (little endian)
    func assemble_opcodes(source: string) {
        var i = 0
        val len = source.length
        while i < len {
            // We will parse 3 dodecagram chars at a time (12^3 = 1728 < 2^16) as one 2-byte opcode
            val slice_len = if (i + 3 <= len) 3 else len - i
            val chunk = source.substr(i, slice_len)
            val opcode_val = Dodecagram.parse_base12(chunk)

            // Emit opcode as little endian 2 bytes
            val low = opcode_val & 0xFF
            val high = (opcode_val >> 8) & 0xFF
            code_bytes.append(low)
            code_bytes.append(high)

            i += 3
        }
    }

    // Build final PE executable bytes
    func build_pe_file() -> bytes {
        // Calculate padding to align code section to 512 bytes (FileAlignment)
        val code_len = code_bytes.length
        val padded_code_len = ((code_len + 0x1FF) & ~0x1FF) // round up to 512
        val padding_len = padded_code_len - code_len

        // Append zeros to code_bytes for padding
        for _ in 0 .. padding_len - 1 {
            code_bytes.append(0)
        }

        // Compose final file:
        val file_bytes = []
        file_bytes.extend(PEHeader.dos_stub)
        // PE header offset is at 0x3C in DOS stub (offset 60)
        // Insert PE signature + COFF + Optional headers + Section headers at offset 0x80
        // So we pad up to 0x80 first
        val pe_header_offset = 0x80
        val current_len = file_bytes.length
        for _ in 0 .. (pe_header_offset - current_len - 1) {
            file_bytes.append(0)
        }

        // Add PE Signature
        file_bytes.extend(PEHeader.pe_sig)
        // Add COFF header
        file_bytes.extend(PEHeader.coff_header)
        // Add Optional header
        file_bytes.extend(PEHeader.optional_header)
        // Add Section header (for .text)
        file_bytes.extend(PEHeader.section_header(padded_code_len))

        // Pad to file alignment (0x400) before code section (PointerToRawData = 0x400)
        val headers_len = file_bytes.length
        for _ in 0 .. (0x400 - headers_len - 1) {
            file_bytes.append(0)
        }

        // Append code bytes (.text section)
        file_bytes.extend(code_bytes)

        return file_bytes
    }

    // Write the output file to disk (binary mode)
    func write_exe(filename: string) {
        val file_data = build_pe_file()
        file_write_binary(filename, file_data)
    }
}

capsule Main {
    import Assembler

    func main() {
        // Sample dodecagram source: simple program to exit (stub)
        // This is a fake opcode sequence for demo purposes: "0a0b01" (just some base-12 digits)
        val sample_source = "0a0b01"

        Assembler.assemble_opcodes(sample_source)
        Assembler.write_exe("output.exe")

        say("Generated output.exe with " + Assembler.code_bytes.length + " bytes of code.")
    }
}

Main.main()
