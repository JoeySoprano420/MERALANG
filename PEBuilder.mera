capsule PEBuilder {
    // Constants for PE Header sizes and offsets
    const DOS_STUB_SIZE = 128
    const PE_HEADER_OFFSET = 0x80
    const SECTION_ALIGNMENT = 0x1000
    const FILE_ALIGNMENT = 0x200

    func build_pe_header(code_size: int, import_size: int) -> bytes {
        var pe = bytes()

        // DOS Stub (128 bytes)
        pe.extend(build_dos_stub())

        // PE Signature "PE\0\0"
        pe.extend([0x50, 0x45, 0x00, 0x00])

        // COFF File Header (20 bytes)
        pe.extend(build_coff_file_header())

        // Optional Header (standard + windows fields)
        pe.extend(build_optional_header(code_size + import_size))

        // Section Headers (code + import)
        pe.extend(build_section_headers(code_size, import_size))

        return pe
    }

    func build_dos_stub() -> bytes {
        var stub = bytes(DOS_STUB_SIZE)
        stub[0] = 0x4D  // 'M'
        stub[1] = 0x5A  // 'Z'
        // Fill remaining with zeros or a minimal DOS stub executable
        stub[0x3C] = PE_HEADER_OFFSET & 0xFF
        stub[0x3D] = (PE_HEADER_OFFSET >> 8) & 0xFF
        stub[0x3E] = (PE_HEADER_OFFSET >> 16) & 0xFF
        stub[0x3F] = (PE_HEADER_OFFSET >> 24) & 0xFF
        return stub
    }

    func build_coff_file_header() -> bytes {
        var header = bytes(20)
        header[0] = 0x4C  // Machine type: x86_64 = 0x8664 (little endian)
        header[1] = 0x86
        header[2] = 0x01  // Number of sections = 1 or 2
        header[3] = 0x00
        // Timestamp, symbol table, etc. zeros for simplicity
        // Size of optional header
        header[16] = 0xF0  // 240 bytes for PE32+
        header[17] = 0x00
        // Characteristics (Executable, Large Address Aware)
        header[18] = 0x02 | 0x20  // Executable Image | Large Address Aware
        header[19] = 0x00
        return header
    }

    func build_optional_header(image_size: int) -> bytes {
        var optional = bytes(240)
        optional[0] = 0x0B  // Magic PE32+
        optional[1] = 0x02
        // AddressOfEntryPoint
        optional[16] = 0x00  // Fill in later
        // BaseOfCode
        optional[20] = 0x1000
        // ImageBase (default 0x140000000)
        // SectionAlignment
        optional[32] = SECTION_ALIGNMENT & 0xFF
        optional[33] = (SECTION_ALIGNMENT >> 8) & 0xFF
        optional[34] = (SECTION_ALIGNMENT >> 16) & 0xFF
        optional[35] = (SECTION_ALIGNMENT >> 24) & 0xFF
        // FileAlignment
        optional[36] = FILE_ALIGNMENT & 0xFF
        optional[37] = (FILE_ALIGNMENT >> 8) & 0xFF
        // SizeOfImage
        val size_image = ((image_size + SECTION_ALIGNMENT - 1) / SECTION_ALIGNMENT) * SECTION_ALIGNMENT
        optional[56] = size_image & 0xFF
        optional[57] = (size_image >> 8) & 0xFF
        optional[58] = (size_image >> 16) & 0xFF
        optional[59] = (size_image >> 24) & 0xFF
        // DataDirectories (Imports etc.) filled later
        return optional
    }

    func build_section_headers(code_size: int, import_size: int) -> bytes {
        var headers = bytes(40 * 2)  // Two sections: .text and .idata

        // .text section header
        headers[0..8] = ".text\0\0\0".encode_utf8()
        val text_size_raw = ((code_size + FILE_ALIGNMENT - 1) / FILE_ALIGNMENT) * FILE_ALIGNMENT
        val text_size_virtual = ((code_size + SECTION_ALIGNMENT - 1) / SECTION_ALIGNMENT) * SECTION_ALIGNMENT
        // VirtualSize
        headers[8..12] = int_to_bytes(code_size)
        // VirtualAddress
        headers[12..16] = int_to_bytes(0x1000)
        // SizeOfRawData
        headers[16..20] = int_to_bytes(text_size_raw)
        // PointerToRawData
        headers[20..24] = int_to_bytes(0x400)
        // Characteristics: Code | Executable | Readable
        headers[36..40] = int_to_bytes(0x60000020)

        // .idata section header
        headers[40..48] = ".idata\0\0\0".encode_utf8()
        val idata_size_raw = ((import_size + FILE_ALIGNMENT - 1) / FILE_ALIGNMENT) * FILE_ALIGNMENT
        val idata_size_virtual = ((import_size + SECTION_ALIGNMENT - 1) / SECTION_ALIGNMENT) * SECTION_ALIGNMENT
        // VirtualSize
        headers[48..52] = int_to_bytes(import_size)
        // VirtualAddress
        headers[52..56] = int_to_bytes(0x2000)
        // SizeOfRawData
        headers[56..60] = int_to_bytes(idata_size_raw)
        // PointerToRawData
        headers[60..64] = int_to_bytes(0x2400)
        // Characteristics: Initialized Data | Readable | Writable
        headers[76..80] = int_to_bytes(0xC0000040)

        return headers
    }

    func int_to_bytes(val: int) -> bytes {
        return [
            val & 0xFF,
            (val >> 8) & 0xFF,
            (val >> 16) & 0xFF,
            (val >> 24) & 0xFF
        ]
    }
}
