capsule MacroProcessor {
    import Lexer
    import Parser

    struct Macro {
        name: string
        params: list<string>
        body_tokens: list<{line:int,text:string,type:string}>
    }

    var macros: dict<string, Macro> = {}
    var call_stack: list<string> = []

    func define_macro() {
        val name = Lexer.consume()?.text
        if name == null {
            error("Expected macro name")
        }
        val params = parse_macro_params()
        val body_tokens = collect_macro_body()
        macros[name] = Macro{name: name, params: params, body_tokens: body_tokens}
    }

    func parse_macro_params() -> list<string> {
        val params = []
        if Lexer.peek()?.text == "(" {
            Lexer.consume()
            while Lexer.peek()?.text != ")" {
                val p = Lexer.consume()?.text
                if p == null {
                    error("Expected macro parameter")
                }
                params.append(p)
                if Lexer.peek()?.text == "," {
                    Lexer.consume()
                }
            }
            Lexer.expect(")")
        }
        return params
    }

    func collect_macro_body() -> list<{line:int,text:string,type:string}> {
        val tokens = []
        while true {
            val tok = Lexer.consume()
            if tok == null {
                error("Unexpected EOF in macro definition")
            }
            if tok.type == "ENDM" {
                break
            }
            tokens.append(tok)
        }
        return tokens
    }

    func expand_macros() {
        var expanded_instructions = []
        for instr in Parser.instructions {
            if macros.contains_key(instr.mnemonic) {
                val macro = macros[instr.mnemonic]
                val expanded = expand_macro_call(macro, instr.operands)
                expanded_instructions.extend(expanded)
            } else {
                expanded_instructions.append(instr)
            }
        }
        Parser.instructions = expanded_instructions
    }

    func expand_macro_call(macro: Macro, args: list<Parser.Operand>) -> list<Parser.Instruction> {
        if args.length != macro.params.length {
            error("Macro " + macro.name + " expects " + macro.params.length + " args but got " + args.length)
        }
        val param_map = dict<string, string>()
        for i in 0 .. macro.params.length - 1 {
            param_map[macro.params[i]] = args[i].text
        }
        val substituted_tokens = []
        for tok in macro.body_tokens {
            if param_map.contains_key(tok.text) {
                substituted_tokens.append({line: tok.line, text: param_map[tok.text], type: tok.type})
            } else {
                substituted_tokens.append(tok)
            }
        }
        val old_tokens = Lexer.tokens
        val old_line = Lexer.current_line
        Lexer.tokens = substituted_tokens
        Lexer.current_line = substituted_tokens[0]?.line ?? 1

        val old_instructions = Parser.instructions
        Parser.instructions = []
        Parser.parse()

        Lexer.tokens = old_tokens
        Lexer.current_line = old_line

        val result = Parser.instructions
        Parser.instructions = old_instructions
        return result
    }
}
