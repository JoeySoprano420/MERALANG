capsule OpcodeTable {
    import Dodecagram
    import SymbolTable
    import RelocationTable

    // Register codes for modrm
    var reg_codes = {
        "eax": 0,
        "ecx": 1,
        "edx": 2,
        "ebx": 3,
        "esp": 4,
        "ebp": 5,
        "esi": 6,
        "edi": 7
    }

    // Encode instruction
    func encode(instr: Parser.Instruction, current_addr: int) -> bytes {
        val m = instr.mnemonic
        val ops = instr.operands

        // mov reg, imm32
        if m == "mov" && ops.length == 2 && reg_codes.contains_key(ops[0]) && ops[1].starts_with("0x") {
            val reg = ops[0]
            val imm_val = parse_hex(ops[1])
            val opcode = 0xB8 + reg_codes[reg]
            return [opcode] + imm32_to_bytes(imm_val)
        }

        // xor reg, reg (e.g. xor eax, eax)
        if m == "xor" && ops.length == 2 && ops[0] == ops[1] && reg_codes.contains_key(ops[0]) {
            val reg = ops[0]
            val modrm = 0xC0 + reg_codes[reg] * 8 + reg_codes[reg]
            return [0x31, modrm]
        }

        // call label
        if m == "call" && ops.length == 1 {
            // Emit opcode 0xE8 + placeholder rel32
            val result = [0xE8, 0, 0, 0, 0]
            RelocationTable.add(current_addr + 1, ops[0]) // patch after assembly
            return result
        }

        // ret
        if m == "ret" && ops.length == 0 {
            return [0xC3]
        }

        error("Unsupported instruction or operands at line " + instr.line + ": " + m + " " + ops.join(", "))
    }

    func imm32_to_bytes(val: int) -> bytes {
        return [
            val & 0xFF,
            (val >> 8) & 0xFF,
            (val >> 16) & 0xFF,
            (val >> 24) & 0xFF
        ]
    }

    func parse_hex(s: string) -> int {
        val hex_str = if s.starts_with("0x") then s.substr(2) else s
        var result = 0
        for ch in hex_str.to_lower() {
            val digit = if ch >= '0' && ch <= '9' then (int)ch - (int)'0'
                        else if ch >= 'a' && ch <= 'f' then 10 + ((int)ch - (int)'a')
                        else error("Invalid hex digit: " + ch)
            result = result * 16 + digit
        }
        return result
    }
}
