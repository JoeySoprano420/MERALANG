capsule OpcodeTable {
    import Dodecagram

    // Registers with their encoding numbers
    var reg_codes = {
        "eax": 0,
        "ecx": 1,
        "edx": 2,
        "ebx": 3,
        "esp": 4,
        "ebp": 5,
        "esi": 6,
        "edi": 7
    }

    // Example instruction encodings (limited subset)
    func encode(instruction: Parser.Instruction) -> bytes {
        val m = instruction.mnemonic
        val ops = instruction.operands
        if m == "mov" && ops.length == 2 {
            if reg_codes.contains_key(ops[0]) && ops[1].starts_with("0x") {
                // mov reg, imm32
                val reg = ops[0]
                val imm_str = ops[1]
                val imm_val = parse_hex(imm_str)
                val opcode_base = 0xB8 + reg_codes[reg]
                return [opcode_base] + imm32_to_bytes(imm_val)
            }
        } else if m == "xor" && ops.length == 2 && ops[0] == ops[1] && reg_codes.contains_key(ops[0]) {
            // xor reg, reg (e.g. xor eax, eax)
            val reg = ops[0]
            val modrm = 0xC0 + reg_codes[reg] * 8 + reg_codes[reg]
            return [0x31, modrm]
        } else if m == "call" && ops.length == 1 {
            // call label (relative)
            // Return dummy 5 bytes for call rel32, to be patched after label resolution
            return [0xE8, 0x00, 0x00, 0x00, 0x00]
        } else if m == "ret" {
            return [0xC3]
        }
        error("Unsupported instruction: " + m + " with operands " + ops.join(", "))
    }

    // Convert imm32 int to 4 bytes little endian
    func imm32_to_bytes(val: int) -> bytes {
        return [
            val & 0xFF,
            (val >> 8) & 0xFF,
            (val >> 16) & 0xFF,
            (val >> 24) & 0xFF
        ]
    }

    func parse_hex(s: string) -> int {
        // strip 0x prefix and parse hex string to int
        val hex_str = s.lower().starts_with("0x") ? s.substr(2) : s
        val result = 0
        for ch in hex_str {
            val digit = if ch >= '0' && ch <= '9' then (int)ch - (int)'0'
                        else if ch >= 'a' && ch <= 'f' then 10 + ((int)ch - (int)'a')
                        else error("Invalid hex digit: " + ch)
            result = result * 16 + digit
        }
        return result
    }
}
