#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <unordered_map>
#include <cctype>
#include <stdexcept>
#include <vector>

class MeraLang {
    std::unordered_map<std::string, int> variables;

    // Remove comments from a line
    std::string strip_comment(const std::string& line) {
        size_t pos = line.find('#');
        return (pos == std::string::npos) ? line : line.substr(0, pos);
    }

    // Trim whitespace
    std::string trim(const std::string& s) {
        size_t start = s.find_first_not_of(" \t");
        size_t end = s.find_last_not_of(" \t");
        return (start == std::string::npos) ? "" : s.substr(start, end - start + 1);
    }

    // Parse and evaluate arithmetic expressions with parentheses and negative numbers
    int eval_factor(std::istringstream& iss) {
        iss >> std::ws;
        char c = iss.peek();
        if (c == '(') {
            iss.get();
            int val = eval_expr(iss);
            iss >> std::ws;
            if (iss.get() != ')')
                throw std::runtime_error("Mismatched parentheses");
            return val;
        } else if (c == '-') {
            iss.get();
            return -eval_factor(iss);
        } else if (std::isdigit(c)) {
            int val;
            iss >> val;
            return val;
        } else if (std::isalpha(c)) {
            std::string var;
            iss >> var;
            if (variables.count(var))
                return variables[var];
            throw std::runtime_error("Undefined variable: " + var);
        }
        throw std::runtime_error("Invalid factor in expression");
    }

    int eval_term(std::istringstream& iss) {
        int val = eval_factor(iss);
        while (true) {
            iss >> std::ws;
            char c = iss.peek();
            if (c == '*' || c == '/') {
                char op;
                iss >> op;
                int rhs = eval_factor(iss);
                if (op == '*') val *= rhs;
                else {
                    if (rhs == 0) throw std::runtime_error("Division by zero");
                    val /= rhs;
                }
            } else break;
        }
        return val;
    }

    int eval_expr(std::istringstream& iss) {
        int val = eval_term(iss);
        while (true) {
            iss >> std::ws;
            char c = iss.peek();
            if (c == '+' || c == '-') {
                char op;
                iss >> op;
                int rhs = eval_term(iss);
                if (op == '+') val += rhs;
                else val -= rhs;
            } else break;
        }
        return val;
    }

    // Evaluate comparison expressions, returns bool as int (1=true, 0=false)
    int eval_condition(const std::string& cond) {
        std::istringstream iss(cond);
        std::string lhs, op, rhs;
        iss >> lhs >> op >> rhs;
        int left = std::isdigit(lhs[0]) || (lhs[0] == '-' && lhs.size() > 1) ? std::stoi(lhs) :
            (variables.count(lhs) ? variables[lhs] : throw std::runtime_error("Undefined variable: " + lhs));
        int right = std::isdigit(rhs[0]) || (rhs[0] == '-' && rhs.size() > 1) ? std::stoi(rhs) :
            (variables.count(rhs) ? variables[rhs] : throw std::runtime_error("Undefined variable: " + rhs));
        if (op == ">") return left > right;
        if (op == "<") return left < right;
        if (op == "==") return left == right;
        if (op == "!=") return left != right;
        if (op == ">=") return left >= right;
        if (op == "<=") return left <= right;
        throw std::runtime_error("Invalid comparison operator: " + op);
    }

    // Print statement: supports string literals and expressions
    void print_stmt(const std::string& expr) {
        std::istringstream iss(expr);
        while (iss >> std::ws) {
            char c = iss.peek();
            if (c == '"') {
                std::string str;
                iss.get(); // skip "
                std::getline(iss, str, '"');
                std::cout << str;
            } else if (c == '\0' || c == EOF) {
                break;
            } else {
                // Parse until next whitespace or quote
                std::string token;
                if (std::isalpha(c)) {
                    iss >> token;
                    if (variables.count(token))
                        std::cout << variables[token];
                    else
                        std::cout << token; // print as is
                } else {
                    // Try to parse an expression
                    std::string expr_part;
                    std::getline(iss, expr_part, ' ');
                    std::istringstream expr_iss(expr_part);
                    try {
                        std::cout << eval_expr(expr_iss);
                    } catch (...) {
                        std::cout << expr_part;
                    }
                }
            }
        }
        std::cout << std::endl;
    }

public:
    void run(const std::string& filename) {
        std::ifstream file(filename);
        if (!file) {
            std::cerr << "Cannot open file: " << filename << std::endl;
            return;
        }
        std::vector<std::string> lines;
        std::string line;
        while (std::getline(file, line)) {
            lines.push_back(line);
        }
        for (size_t i = 0; i < lines.size(); ++i) {
            std::string raw_line = strip_comment(lines[i]);
            std::string line = trim(raw_line);
            if (line.empty()) continue;
            std::istringstream iss(line);
            std::string token;
            iss >> token;
            if (token == "let") {
                std::string var, eq;
                iss >> var >> eq;
                if (eq != "=") {
                    std::cerr << "Syntax error: expected '='\n";
                    continue;
                }
                std::string expr;
                std::getline(iss, expr);
                expr = trim(expr);
                try {
                    std::istringstream expr_iss(expr);
                    variables[var] = eval_expr(expr_iss);
                } catch (const std::exception& e) {
                    std::cerr << "Error: " << e.what() << std::endl;
                }
            } else if (token == "print") {
                std::string expr;
                std::getline(iss, expr);
                expr = trim(expr);
                try {
                    print_stmt(expr);
                } catch (const std::exception& e) {
                    std::cerr << "Error: " << e.what() << std::endl;
                }
            } else if (token == "if") {
                std::string cond, then, rest;
                std::getline(iss, cond, 't'); // up to 't' in 'then'
                cond = trim(cond);
                iss >> then; // should be "hen"
                std::getline(iss, rest);
                if (then != "then") {
                    std::cerr << "Syntax error: expected 'then'\n";
                    continue;
                }
                try {
                    if (eval_condition(cond)) {
                        run_inline(trim(rest));
                    }
                } catch (const std::exception& e) {
                    std::cerr << "Error: " << e.what() << std::endl;
                }
            } else if (token == "while") {
                std::string cond, then, rest;
                std::getline(iss, cond, 't');
                cond = trim(cond);
                iss >> then;
                std::getline(iss, rest);
                if (then != "then") {
                    std::cerr << "Syntax error: expected 'then'\n";
                    continue;
                }
                try {
                    while (eval_condition(cond)) {
                        run_inline(trim(rest));
                    }
                } catch (const std::exception& e) {
                    std::cerr << "Error: " << e.what() << std::endl;
                }
            } else {
                std::cerr << "Unknown statement: " << token << std::endl;
            }
        }
    }

    // Run a single statement (used for if/while bodies)
    void run_inline(const std::string& line) {
        std::string raw_line = strip_comment(line);
        std::string trimmed = trim(raw_line);
        if (trimmed.empty()) return;
        std::istringstream iss(trimmed);
        std::string token;
        iss >> token;
        if (token == "let") {
            std::string var, eq;
            iss >> var >> eq;
            std::string expr;
            std::getline(iss, expr);
            expr = trim(expr);
            try {
                std::istringstream expr_iss(expr);
                variables[var] = eval_expr(expr_iss);
            } catch (const std::exception& e) {
                std::cerr << "Error: " << e.what() << std::endl;
            }
        } else if (token == "print") {
            std::string expr;
            std::getline(iss, expr);
            expr = trim(expr);
            try {
                print_stmt(expr);
            } catch (const std::exception& e) {
                std::cerr << "Error: " << e.what() << std::endl;
            }
        }
    }
};

int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: MeraLangCompiler <source.ml>\n";
        return 1;
    }
    MeraLang compiler;
    compiler.run(argv[1]);
    return 0;
}

