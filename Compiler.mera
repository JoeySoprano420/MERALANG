capsule JITCompiler {
    import Parser
    import OpcodeDatabase
    import Lexer

    struct CompiledOpcode {
        pattern: string
        operand_types: list<string>     // Parsed operand types from pattern
        encode_func: func(list<Parser.Operand>, int) -> bytes
    }

    var compiled_opcodes: dict<string, CompiledOpcode> = {}

    // Parse pattern string like "REG32,IMM32" into operand types list
    func parse_pattern(pattern: string) -> list<string> {
        return pattern.split(",").map(s => s.trim())
    }

    // Compile opcode pattern to a compiled form with fast matching and encoding
    func compile_opcode_pattern(pattern: string) -> CompiledOpcode {
        if compiled_opcodes.contains_key(pattern) {
            return compiled_opcodes[pattern]
        }

        val operand_types = parse_pattern(pattern)

        // Find matching OpcodeEntry in OpcodeDatabase for this pattern
        var matched_entry: OpcodeDatabase.OpcodeEntry? = null
        for entry in OpcodeDatabase.opcode_table {
            if entry.operand_patterns.length == operand_types.length {
                var all_match = true
                for i in 0 .. operand_types.length - 1 {
                    if entry.operand_patterns[i] != operand_types[i] {
                        all_match = false
                        break
                    }
                }
                if all_match {
                    matched_entry = entry
                    break
                }
            }
        }
        if matched_entry == null {
            error("No opcode entry found for pattern: " + pattern)
        }

        val compiled = CompiledOpcode{
            pattern: pattern,
            operand_types: operand_types,
            encode_func: matched_entry.encode_func
        }

        compiled_opcodes[pattern] = compiled
        return compiled
    }

    // Execute compiled opcode encoding with operands, producing bytes
    func execute_opcode(compiled: CompiledOpcode, operands: list<Parser.Operand>, addr: int) -> bytes {
        if operands.length != compiled.operand_types.length {
            error("Operand count mismatch. Expected " + compiled.operand_types.length.to_string() + ", got " + operands.length.to_string())
        }
        // Verify operands match expected types
        for i in 0 .. operands.length - 1 {
            val expected_type = compiled.operand_types[i]
            if !operand_matches(operands[i], expected_type) {
                error("Operand type mismatch at position " + i.to_string() + ": expected " + expected_type + ", got " + operands[i].type)
            }
        }

        // Call the precompiled encoding function
        return compiled.encode_func(operands, addr)
    }

    func operand_matches(op: Parser.Operand, pattern: string) -> bool {
        switch pattern {
            case "REG32": return op.type == "REGISTER"
            case "IMM32": return op.type == "IMMEDIATE"
            case "IMM8": return op.type == "IMMEDIATE"
            case "LABEL": return op.type == "LABEL"
            default: return false
        }
    }
}
