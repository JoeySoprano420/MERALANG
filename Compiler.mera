capsule JITCompiler {
    import Parser
    import OpcodeDatabase
    import CacheManager

    // IR representation for compiled macros
    struct MacroIR {
        instructions: list<Parser.Instruction>
        compiled_binary: bytes
    }

    var macro_ir_cache: dict<string, MacroIR> = {}

    // Compile macro source text into IR and binary
    func compile_macro(macro_name: string, macro_source: string) -> MacroIR {
        if macro_ir_cache.contains_key(macro_name) {
            return macro_ir_cache[macro_name]
        }

        // Parse macro source to instructions (simplified)
        Lexer.tokenize(macro_source)
        Parser.parse()
        val instructions = Parser.instructions.clone()

        // Encode instructions to binary
        var binary = bytes()
        var current_addr = 0
        for instr in instructions {
            val encoded = OpcodeDatabase.encode(instr, current_addr)
            binary.extend(encoded)
            current_addr += encoded.length
        }

        val ir = MacroIR{instructions: instructions, compiled_binary: binary}
        macro_ir_cache[macro_name] = ir
        return ir
    }

    // Execute macro IR with parameters, returning expanded instructions
    func execute_macro_ir(ir: MacroIR, params: dict<string,string>) -> list<Parser.Instruction> {
        // Substitute parameters in instructions
        val expanded = []
        for instr in ir.instructions {
            val new_ops = []
            for op in instr.operands {
                if params.contains_key(op.text) {
                    new_ops.append(Parser.Operand{text: params[op.text], type: op.type})
                } else {
                    new_ops.append(op)
                }
            }
            expanded.append(Parser.Instruction{mnemonic: instr.mnemonic, operands: new_ops, line: instr.line})
        }
        return expanded
    }
}
